import * as os from "os";
import * as path from "path";
import * as tmpPromise from "tmp-promise";
import { TextEncoder } from "util";
import * as vscode from "vscode";
import * as config from "./config";
import { getOrDefault } from "./containers";
import * as editorLib from "./editor-lib";
import { findEnclosingExpression } from "./fracas/syntax";
import * as repl from "./repl";
import * as utils from "./utils";

export function helpWithSelectedSymbol(): void {
    const fracasObject = editorLib.getSelectedSymbol();
    if (fracasObject) {
        utils.openRacketReference(fracasObject);
    }
}

export async function runInTerminal(terminals: Map<string, vscode.Terminal>): Promise<void> {
    utils.withRacketShellCmd(async (racketCmd: string) => {
        const document = vscode.window.activeTextEditor?.document;
        if (document) {
            // precompile dependencies so that the file does not attempt to run out-of-date code.
            await precompileFracasFile(document);
            document.save();
            
            // find a terminal and execute the file.
            const filePath = path.resolve(document.fileName);
            let terminal;
            if (
                vscode.workspace
                    .getConfiguration("vscode-fracas.outputTerminal")
                    .get("numberOfOutputTerminals") === "one"
            ) {
                terminal = getOrDefault(terminals, "one", () => repl.createTerminal(null));
            } else {
                terminal = getOrDefault(terminals, filePath, () => repl.createTerminal(filePath));
            }
            repl.runFileInTerminal(racketCmd, filePath, terminal);
        }
    });
}

export async function loadInRepl(repls: Map<string, vscode.Terminal>): Promise<void> {
    utils.withRacketShellCmd(async (racketCmd: string) => {
        const document = vscode.window.activeTextEditor?.document;
        if (document) {
            // precompile dependencies so that the file does not attempt to run out-of-date code.
            await precompileFracasFile(document);
            document.save();
            
            const filePath = path.resolve(document.fileName);
            const replTerminal = getOrDefault(repls, filePath, () => repl.createRepl(path.basename(filePath), racketCmd));
            repl.loadFileInRepl(filePath, replTerminal);
        }
    });
}

export async function executeSelection(repls: Map<string, vscode.Terminal>): Promise<void> {
    const filePath = vscode.window.activeTextEditor?.document?.fileName;
    if (filePath) {
        await repl.withRepl(repls, filePath, repl.executeSelectionInRepl);
    }
}

/**
 * finds all localized-text*.frc files, converts the filenames into .csv file
 * names, and invokes racket to generate TdpLocalization.cpp/h
 */
export async function makeStringTableImport(): Promise<void> {
    const racket = config.getRacketShellCmd();
    const stringTableCpp = vscode.workspace
        .getConfiguration("vscode-fracas.general")
        .get<string>("stringTableRegistryFile")
        ?? "..\\tdp1.unreal\\Source\\Data\\Private\\TdpLocalization.cpp";
    const projectDir = config.getProjectDir();
    const stringTableDestDir = vscode.workspace
        .getConfiguration("vscode-fracas.localization")
        .get<string>("stringTableDestDir") ?? ".";
    const stringTableSourcePaths = vscode.workspace
        .getConfiguration("vscode-fracas.localization")
        .get<string[]>("stringTableSourcePaths") ?? [];

    if (racket) {
        const textFrcFiles = [];
        for (const pathPattern of stringTableSourcePaths) {
            const glob = new vscode.RelativePattern(vscode.Uri.file(projectDir), pathPattern);
            textFrcFiles.push(...await vscode.workspace.findFiles(glob));
        }
        textFrcFiles.sort();
        const csvFiles = textFrcFiles.map(frcFile => {
            const csvBaseName = utils.kebabCaseToPascalCase(path.basename(frcFile.fsPath, ".frc"));
            const csvFile = path.resolve(`${projectDir}\\${stringTableDestDir}\\${csvBaseName}.csv`);
            return csvFile;
        });

        config.fracasOut.appendLine(`Generating ${textFrcFiles.length} text source files into "${stringTableCpp}"`);

        const cmd = `${racket} ../fracas/lib/fracas/make-string-table-import.rkt -- ${csvFiles.join(" ")}`;
        await utils.execShellWithProgress(cmd, `Generating ${path.basename(stringTableCpp)}`);
    }
}

const JSON_PROJECT_PATHS_MARKER = ";; <auto-generated> Generated by Fracas VS Code Extension. DO NOT EDIT!";
/**
 * Update project.rktd to include all fracas files containing a `define-game-data` statement
 * in the `json` project category. Files in this category are used as source to generate json
 * when fracas is built.
 * @param token cancel background text search when the task is cancelled
 * @returns a promise that updates project.rktd when it resolves
 */
export async function updateProjectFileJsonCategory(token?: vscode.CancellationToken): Promise<void> {
    const projectRktd = vscode.workspace
        .getConfiguration("vscode-fracas.general")
        .get<string>("projectFile")
        ?? "project.rktd";
    const projectFolder = config.getProjectFolder();
    const projectFileUri = vscode.Uri.joinPath(projectFolder.uri, projectRktd);
    const projectDoc = await vscode.workspace.openTextDocument(projectFileUri);

    // find the project category expression for JSON targets, e.g.
    // #s(project-category
    //    json
    const jsonCategoryRange = await findJsonProjectPathsExpression();
    if (jsonCategoryRange === undefined) {
        vscode.window.showErrorMessage(`No "json" category found in ${projectRktd}.`);
        return;
    }

    // Find all unique fracas files containing a (define-game-data ...) expression
    const gameDataDefines = await editorLib.findTextInFiles("^\\s*\\(define-game-data\\b", token);
    const nonJsonDirs = [
        "fracas/platform/",
        "fracas/platform-login-data.frc",
        "fracas/abilities/",
        "fracas/tags/",
        "fracas/text/",
        "fracas/localization-defines.frc" 
    ]
    const gameDataFiles = [... new Set(gameDataDefines
        .map(match => "fracas/" + vscode.workspace.asRelativePath(match.uri, false))
        .filter(relativePath => nonJsonDirs.find(dir => relativePath.startsWith(dir)) === undefined)
    )].sort();
    if (gameDataFiles.length === 0) {
        return;
    }

    // convert fracas file URIs into frake project-path-info declarations, e.g.
    // #s(project-path-info "fracas/items" "item-info.frc")
    const projectPathInfos = gameDataFiles.map(relativePath =>
        `        #s(project-path-info "${path.dirname(relativePath)}" "${path.basename(relativePath)}")`)
    
    // construct the body of the project category expression
    const prevPathInfoContent = projectDoc.getText(jsonCategoryRange);
    const newline = projectDoc.eol === vscode.EndOfLine.LF ? "\n" : "\r\n";
    const pathInfoContent = 
        JSON_PROJECT_PATHS_MARKER + newline + 
        projectPathInfos.join(newline) + newline + 
        '        ;; @TODO: JIRA-12628 platform data that is bundled in the GDR temporarily but should be platform authoritative' + newline +
        '        #s((project-path-info-opt project-path-info 2) "fracas" "platform-login-data.frc" (#:not-in-registry))' + newline +
        '        ;; </auto-generated>' + newline +
        '       ';
    if (prevPathInfoContent == pathInfoContent) {
        config.fracasOut.appendLine(`Project already up-to-date with ${projectPathInfos.length} project paths in "${projectRktd}"`);
        return;
    }
    
    // write the changes
    config.fracasOut.appendLine(`Writing ${projectPathInfos.length} project paths into "${projectRktd}"`);
    const pathInfoEdit = new vscode.WorkspaceEdit()
    pathInfoEdit.replace(projectFileUri, jsonCategoryRange, pathInfoContent);
    let success = await vscode.workspace.applyEdit(pathInfoEdit);
    if (success) {
        success = await projectDoc.save();
    }

    if (success) {
        vscode.window.showInformationMessage(`Updated game data paths in ${projectRktd}`)
    } else {
        vscode.window.showErrorMessage(`Failed to update ${projectRktd} JSON file list.`);
    }

    async function findJsonProjectPathsExpression() {
        const jsonPaths = await editorLib.searchForward(projectDoc, new RegExp(JSON_PROJECT_PATHS_MARKER));
        if (jsonPaths)
        {
            const { line, match } = jsonPaths;
            return findEnclosingExpression(projectDoc, new vscode.Position(line.lineNumber, match.index), false)
        }
        return undefined;
    }
}

export async function compileFracasObject(filePath: string, fracasObject: string): Promise<void> {
    const racket = config.getRacketShellCmd();
    if (fracasObject && filePath && racket) {
        vscode.window.activeTextEditor?.document?.save();
        const racketExpr = `(require fracas/make-asset) (enter! (file "${filePath}")) (define-asset-impl: #:value ${fracasObject} #:value-name (quote ${fracasObject}) #:key (key: ${fracasObject}))`;
        const cmd = `${racket} -e "${racketExpr.replace(/"/g, '\\"')}"`
        await utils.execShellWithProgress(cmd, `Compiling ${fracasObject}`);
    }
}

let lastFracasObject = "";
let lastFracasFile = "";
export function compileSelectedFracasObject(): void {
    lastFracasFile = vscode.window.activeTextEditor?.document?.fileName ?? "";
    lastFracasObject = editorLib.getSelectedSymbol();
    compileFracasObject(lastFracasFile, lastFracasObject);
}

export function recompileFracasObject(): void {
    compileFracasObject(lastFracasFile, lastFracasObject);
}

export async function precompileFracasFile(frcDoc: vscode.TextDocument | undefined = undefined): Promise<void> {
    // use the open document if none is provided
    if (frcDoc === undefined) {
        frcDoc = vscode.window.activeTextEditor?.document;
    }

    // if there is a fracas document, precompile it
    if (frcDoc && frcDoc.languageId === "fracas") {
        try {
            // disable fracas commands until precompilation is done
            vscode.commands.executeCommand('setContext', 'vscode-fracas.ready', false);

            frcDoc.save(); // save the document before precompiling
    
            const ninja = config.getNinja();
    
            // Invoke ninja to update all precompiled zo file dependencies
            const precompileNinjaFile = path.join("build", "build_precompile.ninja");
            const projectFolder = config.getProjectFolder();
    
            try {
                // make sure build_precompile.ninja exists. Users with pre-built binaries may not have this file
                await vscode.workspace.fs.stat(vscode.Uri.joinPath(projectFolder.uri, precompileNinjaFile));
            } catch {
                config.fracasOut.appendLine("Skip precompiling because build_precompile.ninja does not exist");
                return;
            }
    
            const coresUsed = Math.ceil(os.cpus().length / 2); // use half the cores available to prevent starvation
            const ninjaCmd = `"${ninja}" -j ${coresUsed} -f "${precompileNinjaFile}"`;
            config.fracasOut.appendLine(`Precompiling fracas files with ${coresUsed} cores because ${frcDoc.fileName} has changed: ${ninjaCmd}`);

            const execOpts = {
                workingDir: projectFolder.uri.fsPath,
                showErrors: false,
                timeoutMillis: 240_000,
                lowPriority: true,
                serializedExecutionKey: "precompileFracasFile"
            };
            await utils.execShellWithProgress(ninjaCmd, "Compiling Fracas", execOpts);
        } finally {
            // re-enable fracas commands
            vscode.commands.executeCommand('setContext', 'vscode-fracas.ready', true);
        }
    }
}

export function openRepl(repls: Map<string, vscode.Terminal>): void {
    editorLib.withFilePath((filePath: string) => {
        utils.withRacketShellCmd((racketCmd: string) => {
            const replTerminal = getOrDefault(repls, filePath, () => repl.createRepl(path.basename(filePath), racketCmd));
            replTerminal.show();
        });
    });
}

export function showOutput(terminals: Map<string, vscode.Terminal>): void {
    editorLib.withFilePath((filePath: string) => {
        const terminal = terminals.get(filePath);
        if (terminal) {
            terminal.show();
        } else {
            vscode.window.showErrorMessage("No output terminal exists for this file");
        }
    });
}

export async function formatFracasDocument(
    frcDoc?: vscode.TextDocument,
    options?: vscode.FormattingOptions,
    range?: vscode.Range | vscode.Position
): Promise<vscode.TextEdit[]> {
    // use the open document if none is provided
    if (frcDoc === undefined) {
        frcDoc = vscode.window.activeTextEditor?.document;
    }

    // if there is a fracas document, format it
    if (frcDoc !== undefined) {
        // Expand selection range to a valid expression
        if (range) {
            range = editorLib.resolveRange(range);
            // console.log(frcDoc.getText(range) + "\n");
            range = findEnclosingExpression(frcDoc, range);
            if (!range || range.isEmpty) {
                return [];
            }
        }

        // Invoke yasi to generate formatted text.
        const fracasText = frcDoc.getText(range);
        const newline = frcDoc.eol === vscode.EndOfLine.LF ? "\n" : "\r\n";
        const diff = await tmpPromise.withFile(f => {
            const fileBytes = new TextEncoder().encode(fracasText.endsWith(newline) ? fracasText : fracasText + newline);
            vscode.workspace.fs.writeFile(vscode.Uri.file(f.path), fileBytes);
            const indent = options?.tabSize ?? 2;
            const cmd = [
                `"${config.getPython()}"`,
                `"${config.getFormatterScript()}"`,
                "--diff",
                "--indent-size", indent.toString(),
                "--default-indent", indent.toString(),
            ];
            if (frcDoc?.languageId === 'fracas') {
                cmd.push("--dialect", "fracas");
            }
            if (config.shouldFormatterIndentComments()) {
                cmd.push("--indent-comments");
            }
            if (!options?.insertSpaces) {
                cmd.push("--tab", indent.toString());
            }
            cmd.push(f.path);
            const formatCmd = cmd.join(" ");
            // console.log(fracasText);
            config.fracasOut.appendLine(formatCmd);
            return utils.execShell(formatCmd);
        });

        // convert diff to text edits and move them to the correct position
        if (diff) {
            const edits = editorLib.diffToTextEdits(diff, newline);
            if (range && range.start.isAfter(new vscode.Position(0, 0))) {
                _textEditsToDocumentEdits(fracasText, edits, frcDoc, range.start, newline);
            }
            return edits;
        }
    }

    return [];
}

function _textEditsToDocumentEdits(
    editedText: string,
    textEdits: vscode.TextEdit[],
    document: vscode.TextDocument,
    documentPos: vscode.Position,
    newline = "\r\n",
    options?: vscode.FormattingOptions
): void {
    // offset the edits by the offset
    const exprIndent = (options === undefined || options.insertSpaces) ?
        " ".repeat(documentPos.character) :
        "\t".repeat(documentPos.character / options.tabSize) + " ".repeat(documentPos.character % options.tabSize);
    const editRanges = textEdits.map(edit => edit.range);
    // Translate text edit offsets to the position of the selected expression
    const documentRanges = editorLib.textRangesToDocumentRanges(editedText, editRanges, newline, document, documentPos);

    for (let index = 0; index < textEdits.length; index++) {
        const edit = textEdits[index];
        edit.range = documentRanges[index];
        // Indent the text edit lines to match the selected expression
        if (exprIndent.length > 0) {
            edit.newText = edit.newText
                .split(newline)
                .map(line => exprIndent + line) // prepend the indent to each line
                .join(newline)
                .substring(exprIndent.length); // drop indent from first line, which is already indented.
        }
    }
}
